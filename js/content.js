"use strict";
var contentData = // jshint ignore:line
{
  "vertices-and-edges": {

    "content-title": "الرؤوس والأضلاع",

    "theory-content": `
    <div>
      <p>
        <span style='whitespace: nowrap'>
          البيان
          (Graph)
          هو مجموعة من الرؤوس
          (Vertices)
        </span>
        <span style='whitespace: nowrap'>
          <svg width=30 height=30 xml:space='preserve' style='margin-left: 4px; margin-right: 0 position:relative'>
            <g>
              <circle cx='15' cy='15' r='10' fill='#1f77b4'/>
            </g>
          </svg>
        </span>
        <span style='whitespace: nowrap'>
          <svg width=30 height=30 xml:space='preserve' style='margin-left: 0; margin-right: 0; position:relative'>
            <g>
              <circle cx='15' cy='15' r='10' fill='#ff7f0e'/>
            </g>
          </svg>
        </span>
        <span style='whitespace: nowrap'>
          <svg width=30 height=30 xml:space='preserve' style='margin-left: 0; margin-right: 4px; position:relative'>
            <g>
              <circle cx='15' cy='15' r='10' fill='#2ca02c'/>
            </g>
          </svg>
        </span>
        <span style='whitespace: nowrap'>
          متصلة بواسطة الأضلاع
          (Edges)
        </span>
        <span style='whitespace: nowrap'>
          <svg width=30 height=30 xml:space='preserve' style='margin-left: 4px; margin-right: 0 position:relative'>
            <g>
              <line x1='5' y1='25' x2='25' y2='5' stroke='#888' stroke-width='2px' stroke-linecap='round' stroke-linejoin='round'/>
            </g>
          </svg>
        </span>
        <span style='whitespace: nowrap'>
          <svg width=30 height=30 xml:space='preserve' style='margin-left: 0; margin-right: 0; position:relative'>
            <g>
              <line x1='5' y1='25' x2='25' y2='5' stroke='#888' stroke-width='2px' stroke-linecap='round' stroke-linejoin='round'/>
            </g>
          </svg>
        </span>
        <span style='whitespace: nowrap'>
          <svg width=30 height=30 xml:space='preserve' style='margin-left: 0; margin-right: 0; position:relative'>
            <g>
              <line x1='5' y1='25' x2='25' y2='5' stroke='#888' stroke-width='2px' stroke-linecap='round' stroke-linejoin='round'/>
            </g>
          </svg>
        </span>
        <span style='whitespace: nowrap'>
          . نرمز لمجموعة جميع الرؤوس بـ
          \\(V\\)
          ومجموعة جميع الأضلاع بـ
          \\(E\\)
          .
        </span>
      </p>
      <p>
        فهمت؟ الآن بكلمات بسيطة: البيان له مكونان - 
        <b>
          مجموعة من الرؤوس
        </b>
        \\(V\\)
        و
        <b>
          مجموعة من الأضلاع
        </b>
        \\(E\\)
        . حيث أن الضلع هو شيء يعمل كرابط بين رأسين. انتهى.
      </p>
      <p>
        إذا كان ضلع يربط بين رأسين
        \\(v_1\\)
        و
        \\(v_2\\)
        ، فإننا نرمز للضلع بـ
        \\(v_1v_2\\)
        ، وهو نفس الشيء مثل
        \\(v_2v_1\\)
        .
      </p>
      <p>
        يقال أن رأسين
        <b>
          متجاوران
          (Adjacent)
        </b>
        إذا كانا متصلين بضلع.
      </p>
      <p>
        الآن اقرأ التعليمات أدناه وأنشئ بيانك الخاص. سترى المجموعات المقابلة
        \\(V\\)
        و
        \\(E\\)
        أسفل منطقة البيان. ابدأ باللعب وتعود على تدوينات المجموعات.
      </p>
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          اضغط بالزر الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          اضغط بالزر الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط مع الاستمرار على Ctrl واسحب
        </b>
        .
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          مرر مؤشر الفأرة
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": "",

    "prev": "index.html",
    "next": "?order-and-size",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "order-and-size": {

    "content-title": "رتبة وحجم البيان",

    "theory-content": `
    <p>
      <b>
        رتبة
        (Order)
      </b>
      البيان هي عدد الرؤوس في البيان.
    </p>
    <p>
      <b>
        حجم
        (Size)
      </b>
      البيان هو عدد الأضلاع في البيان.
    </p>
    <p>
      أنشئ بعض البيانات الخاصة بك ولاحظ رتبتها وحجمها.
      قم بذلك عدة مرات لتعتاد على المصطلحات.
    </p>
    <p>
      الآن امسح البيان وارسم عددًا من الرؤوس (قل
      \\(n\\)
      ). حاول تحقيق الحجم الأقصى مع هذه الرؤوس.
      جرب ذلك لقيم مختلفة من
      \\(n\\)
      .
    </p>
    <p>
      هل لاحظت شيئًا؟ ما هو الحجم الأقصى الممكن لبيان برتبة
      \\(n\\)
      ؟
    </p>
    <div class="hint">
      <span class="hint-word">
        تلميح:
      </span>
      يتم تحقيق الحجم الأقصى عندما تكون جميع الرؤوس متصلة ببعضها البعض.
    </div>
    <p>
      الإجابة أدناه. لا، لا تنظر بعد.
      امسح البيان وحاول مرة أخرى عدة مرات.
    </p>
    <div class="toggle-container">
      <span class="toggle-link target-hidden">
        انقر لرؤية الإجابة
      </span>
      <div class="toggle-content">
        <p>
          الإجابة هي
          \\(\\frac{n(n-1)}{2}\\)
          .
        </p>
        <p>
          ولكن لماذا؟
          لأن العدد الأقصى من الأضلاع التي يمكنك رسمها
          هو نفس عدد الطرق التي يمكنك بها اختيار رأسين.
        </p>
        <p>
          لذا دعونا نختار الرأس الأول ونسميه
          \\(a\\)
          . يمكننا اختيار
          \\(a\\)
          بـ
          \\(n\\)
          طرق
          . لاختيار الرأس الآخر، يتبقى لدينا
          \\(n-1\\)
          رؤوس. لذا يمكننا اختيار رأسين بـ
          \\(n(n-1)\\)
          طرق
          ، صحيح؟
        </p>
        <p>
          لا. ذلك لأننا حسبنا مرتين. ماذا لو كان
          \\(b\\)
          هو الاختيار الأول و
          \\(a\\)
          هو الآخر؟ فهمت؟ تذكر أن
          \\(ab\\)
          و
          \\(ba\\)
          يمثلان نفس الضلع.
        </p>
        <p>
          لذلك نقسم على
          \\(2\\)
          ونحصل على
          \\(\\frac{n(n-1)}{2}\\)
          كالإجابة.
        </p>
      </div>
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          اضغط بالزر الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          اضغط بالزر الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط مع الاستمرار على Ctrl واسحب
        </b>
        .
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          مرر مؤشر الفأرة
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text"  style="text-align: center">
    </div>`,

    "prev": "?vertices-and-edges",
    "next": "?degree-of-vertex",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "degree-of-vertex": {

    "content-title": "درجة الرأس",

    "theory-content": `
    <p>
      <b>
        درجة
        (Degree)
      </b>
      الرأس هي عدد الأضلاع التي تقع عليه.
      تخبرنا بعدد الرؤوس الأخرى المتجاورة مع هذا الرأس.
    </p>
    <p>
      في الشكل المجاور، كل رأس معلم بدرجته.
      قم ببعض التغييرات وانظر كيف تتغير درجة الرؤوس.
    </p>
    <p>
      درجة الرأس
      \\(v\\)
      نرمز لها بـ
      \\(deg(v)\\)
      . الرؤوس التي تحقق
      \\(deg(v)=0\\)
      هي ذئاب وحيدة &mdash; غير مرتبطة بأي أحد.
      لدينا اسم خاص لها.
    </p>
    <p>
      الرؤوس التي لها
      <b>
        درجة صفر
      </b>
      تسمى
      <b>
        رؤوس معزولة
        (Isolated Vertices)
      </b>
      لا يوجد لديها أي رأس آخر متصل بها.
    </p>
    <p>
      الدرجة الدنيا في بيان
      \\(G\\)
      نرمز لها بـ
      \\(\\delta(G)\\)
      . والدرجة القصوى نرمز لها بـ
      \\(\\Delta(G)\\)
      . لتجنب الخلط بينهما، تذكر أن
      \\(\\delta\\)
      هو "دلتا الصغيرة" و
      \\(\\Delta\\)
      هو "دلتا الكبيرة".
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      تذكر أن
      \\(\\delta\\)
      و
      \\(\\Delta\\)
      هما خصائص للبيان، بينما
      \\(deg\\)
      هو خاصية للرأس.
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          اضغط بالزر الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          اضغط بالزر الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط مع الاستمرار على Ctrl واسحب
        </b>
        .
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          مرر مؤشر الفأرة
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": "",

    "prev": "?order-and-size",
    "next": "?degree-sequence",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "degree-sequence": {

    "content-title": "متتالية درجات البيان",

    "theory-content": `
    <p>
      <b>
        متتالية الدرجات
        (Degree Sequence)
      </b>
      للبيان هي قائمة بدرجات جميع رؤوس البيان.
      عادةً ما نقوم بإدراج الدرجات بترتيب
      <b>
        غير متزايد
      </b>
      ، أي من الدرجة الأكبر إلى الدرجة الأصغر.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      متتالية الدرجات دائمًا غير متزايدة. لذلك، كل بيان له
      <b>
        متتالية درجات فريدة.
      </b>
    </div>
    <p>
      في الشكل المجاور، النص داخل كل رأس يوضح درجته.
      ارسم بعض البيانات الخاصة بك وشاهد متتالية درجاتها.
    </p>
    <p>
      ستلاحظ أن مجموع متتالية الدرجات دائمًا ما يكون ضعف حجم البيان.
      هذا في الواقع نتيجة مثبتة رياضيًا (مبرهنة).
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة:
      </span>
      مجموع درجات جميع رؤوس البيان هو ضعف حجم البيان.
      <p>
        رياضيًا،
        \\[\\sum deg(v_i)=2|E|\\]
        حيث،
        \\(|E|\\)
        يمثل عدد الأضلاع في البيان (حجم البيان).
      </p>
    </div>
    <p>
      السبب وراء هذه النتيجة بسيط جدًا.
      الضلع هو رابط بين رأسين.
      لذا كل ضلع يساهم بالضبط
      \\(2\\)
      في مجموع الدرجات.
      ومن ثم، يجب أن يكون مجموع الدرجات ضعف عدد الأضلاع.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          اضغط بالزر الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          اضغط بالزر الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط مع الاستمرار على Ctrl واسحب
        </b>
        .
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          مرر مؤشر الفأرة
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text"  style="text-align: center">
    </div>`,

    "prev": "?degree-of-vertex",
    "next": "?graphic-sequence",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "graphic-sequence": {

    "content-title": "متتالية بيانية",

    "theory-content": `
    <p>
      يقال أن متتالية من الأرقام هي
      <b>
        متتالية بيانية
        (Graphic Sequence)
      </b>
      إذا استطعنا إنشاء بيان يحتوي على هذه المتتالية كمتتالية درجاته.
    </p>
    <p>
      حسنًا، كان ذلك قليلاً مربكًا. فما هي المتتالية البيانية مرة أخرى؟
    </p>
    <p>
      لنفترض أن لديك قائمة من الأرقام.
      قم بتعيين كل رقم إلى رأس معزول.
      الآن، هل يمكنك ربط هذه الرؤوس بطريقة تجعل كل رأس متجاورًا مع عدد من الرؤوس يساوي الرقم المعين له؟
      إذا كان الجواب نعم، فإن قائمة الأرقام بيانية.
      وإلا فلا. ستتضح الأمور بعد قليل.
    </p>
    <p>
      <b>
        مثال 1:
      </b>
      المتتالية
      \\((3,3,2,1,1,0)\\)
      بيانية. في الشكل المجاور، يمكنك رؤية الرؤوس لها هذه الأرقام كدرجاتها.
      لاحظ أن المتتالية تبقى بيانية حتى عند إزالة
      \\(0\\).
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      المتتالية التي تحتوي فقط على أصفار هي دائمًا بيانية.
    </div>
    <p>
      <b>
        مثال 2:
      </b>
      المتتالية
      \\((4,3,2,1)\\)
      ليست بيانية.
      نحتاج على الأقل إلى أربعة رؤوس أخرى لتلبية درجة الرأس الذي لديه
      \\(4\\)
      كدرجته. ولكن لدينا فقط ثلاثة.
    </p>
    <p>
      <b>
        مثال 3:
      </b>
      المتتالية
      \\((4,3,3,2,2,1)\\)
      ليست بيانية. تذكر أن مجموع الدرجات هو
      <b>
        ضعف
      </b>
      عدد الأضلاع.
      لذا يجب أن يكون مجموع المتتالية البيانية زوجيًا.
      وهذا ليس الحال هنا.
    </p>
    <p>
      المتتاليات التالية بيانية.
      حاول رسم بيان لكل منها.
      يمكنك رؤية الإجابة بالنقر على الرابط بجانبها.
    </p>
    <p>
      \\((5,1,1,1,1,1)\\)
      <span class="graph-event-link" id="prob0">
        عرض الحل
      </span>
    </p>
    <p>
      \\((2,2,2,2,2)\\)
      <span class="graph-event-link" id="prob1">
        عرض الحل
      </span>
    </p>
    <p>
      \\((4,4,4,4,4,0)\\)
      <span class="graph-event-link" id="prob2">
        عرض الحل
      </span>
    </p>
    <p>
      \\((3,3,2,2,2)\\)
      <span class="graph-event-link" id="prob3">
        عرض الحل
      </span>
    </p>
    <p>
      \\((5,3,3,3,2,2)\\)
      <span class="graph-event-link" id="prob4">
        عرض الحل
      </span>
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      للبيان متتالية درجات فريدة.
      ولكن قد يكون هناك أكثر من بيان مختلف لنفس المتتالية البيانية.
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        عليه.
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          حرك المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text"  style="text-align: center">
    </div>`,

    "prev": "?degree-sequence",
    "next": "?havel-hakimi",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "havel-hakimi": {

    "content-title": "خوارزمية هافيل-حكيمي",

    "theory-content": `
    <p>
      من الصعب تحديد ما إذا كانت المتتالية بيانية أم لا. تجعل
      <b>
        مبرهنة هافيل-حكيمي
        (Havel-Hakimi Theorem)
      </b>
      المهمة أسهل بكثير.
    </p>
    <p>
      اطلع على المبرهنة أو يمكنك تخطيها والانتقال إلى الخوارزمية في الأسفل.
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة هافيل-حكيمي:
      </span>
      المتتالية غير المتزايدة
      \\[(d_1, d_2, ..., d_n)\\]
      هي بيانية إذا وفقط إذا كانت المتتالية
      \\[ (d_2-1, d_3-1, ..., d_{d_1+1}-1, \\\\d_{d_1+2}, d_{d_1+3}, ..., d_n) \\]
      بيانية أيضًا.
    </div>
    <p>
      هل رأيت كيف تم بناء المتتالية الثانية؟
      المتتالية الأولى غير متزايدة،
      مما يعني أن أعلى درجة فيها هي
      \\(d_1\\).
      أخذنا الرأس الذي لديه أعلى درجة
      (\\(d_1\\))
      وربطناه مع
      \\(d_1\\)
      من الرؤوس التالية ذات الدرجات الأعلى.
      في المتتالية الجديدة،
      استنفدنا الخانة الأولى من المتتالية السابقة وقللنا
      \\(d_1\\)
      من الخانات التالية بمقدار واحد.
    </p>
    <p>
      الآن، تقول المبرهنة أن كلا المتتاليتين إما بيانيتين أو غير بيانيتين.
      يمكننا تطبيق المبرهنة مرة أخرى على المتتالية الجديدة للحصول على متتالية أخرى.
      يمكننا تكرار هذه العملية حتى تتقلص المسألة إلى مسألة سهلة.
      وبالتالي ستكون جميع المتتاليات التي تم الحصول عليها في هذه العملية بيانية أو لا تكون أي منها كذلك.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      قد لا تكون المتتالية التي تم الحصول عليها بعد تطبيق المبرهنة غير متزايدة.
      في مثل هذه الحالة، سيتعين عليك إعادة ترتيبها بترتيب غير متزايد قبل إعادة تطبيق المبرهنة.
    </div>
    <p>
      يمكنك التحقق من هذا
      <a href="https://en.wikipedia.org/wiki/Havel–Hakimi_algorithm" target="_blank">
        الرابط على ويكيبيديا
      </a>
      لمزيد من المعلومات. يمكنك البحث على الإنترنت عن إثبات المبرهنة.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      المتتالية التي تحتوي على جميع الأصفار هي بيانية لأننا يمكننا دائمًا رسم هذا العدد من الرؤوس المعزولة.
    </div>
    <p>
      مهمتك الآن هي رسم بيان لكل من المتتاليات البيانية المعطاة جانباً. لهذه المهمة، يمكنك
      <b>
        استخدام الخوارزمية التالية
      </b>
      التي تعتمد على المبرهنة المذكورة أعلاه.
    </p>
    <div class="result">
      <span class="result-word">
        خوارزمية:
      </span>
      <p></p>
      <ol>
        <li>
          اختر الرأس ذو الدرجة المستهدفة الأعلى. دعنا نسمي هذه القيمة
          \\(k\\).
        </li>
        <li>
          اربط هذا الرأس مع
          \\(k\\)
          من الرؤوس التالية ذات الدرجات الأعلى. الآن تم استنفاد هذا الرأس.
        </li>
        <li>
          كرر الخطوتين 1 و2 حتى تستنفد جميع الرؤوس.
        </li>
        <li>
          إذا تم استنفاد جميع الرؤوس،
          فإن المتتالية قد تقلصت إلى جميع الأصفار وبالتالي فإن المتتالية بيانية.
        </li>
        <li>
          إذا انتهيت برؤوس غير صفرية لا يمكن استنفادها أكثر،
          فإن المتتالية ليست بيانية.
        </li>
      </ol>
    </div>
    <p>
      جميع المتتاليات في هذا التمرين بيانية.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        عليه.
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          حرك المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

      "svg-buttons": `
    <button type="button" id="prev-prob" class="btn btn-default">
      السابق
    </button>
    <button type="button" id="clear-edges" class="btn btn-default">
      إعادة تعيين الأضلاع
    </button>
    <button type="button" id="next-prob" class="btn btn-default">
      التالي
    </button>`,

    "svg-output": `
    <div class="text-center">
      <ul class="pagination" id="prob-list">
        <li><a>1</a></li>
        <li><a>2</a></li>
        <li><a>3</a></li>
        <li><a>4</a></li>
        <li><a>5</a></li>
        <li><a>6</a></li>
        <li><a>7</a></li>
        <li><a>8</a></li>
        <li><a>9</a></li>
        <li><a>10</a></li>
        <li><a>11</a></li>
        <li><a>12</a></li>
      </ul>
    </div>`,

    "prev": "?graphic-sequence",
    "next": "?pigeonhole",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "pigeonhole": {

    "content-title": "مبدأ برج الحمام",

    "theory-content": `
    <p>
      مبدأ برج الحمام
      (Pigeonhole Principle)
      بسيط وبديهي للغاية، لكن تطبيقاته في الرياضيات المتقطعة عديدة بشكل مدهش.
    </p>
    <div class="result">
      <span class="result-word">
        مبدأ برج الحمام:
      </span>
      إذا وضعنا
      \\(n\\)
      من الحمامات في أقل من
      \\(n\\)
      من الأبراج، فإن هناك على الأقل برج واحد يحتوي على أكثر من حمامة واحدة.
    </div>
    <p>
      يمكنك استبدال
      <i>
        الحمامات
      </i>
      بـ
      <i>
        العناصر
      </i>
      و
      <i>
        الأبراج
      </i>
      بـ
      <i>
        الصناديق
      </i>.
      لذا يقول المبدأ إنه إذا كان لدينا عناصر أكثر وصناديق أقل،
      ووزعنا جميع العناصر في هذه الصناديق،
      فإن هناك على الأقل صندوق واحد سيحتوي على أكثر من عنصر واحد.
    </p>
    <p>
      الجزء الصعب هو تطبيق هذه المبرهنة.
      سيتعين عليك تحديد ما هي الأشياء التي تمثل الحمامات والأبراج.
    </p>
    <p>
      <b>
        مثال 1:
      </b>
      هل لاحظت أن هناك عشرة ألوان مختلفة فقط للرؤوس في هذه الدروس؟
      لذا إذا كان هناك أكثر من عشرة رؤوس في البيان،
      فإن هناك على الأقل زوج من الرؤوس له نفس اللون!!
      تحقق من ذلك بنفسك.
      يمكن اعتبار الألوان العشرة كأبراج عشرة.
      وكل رأس كحمامة.
    </p>
    <div class="result">
      <span class="result-word">
        مثال 2:
      </span>
      في أي بيان يحتوي على أكثر من رأس واحد،
      هناك على الأقل زوج من الرؤوس له نفس الدرجة.
    </div>
    <p>
      هذا يعني أنك لا تستطيع الحصول على بيان برتبة
      \\(order\\geq 2\\)
      مع جميع الدرجات مميزة (مختلفة) تماماً.
      ستتكرر بعض الدرجات بالتأكيد. تحقق من ذلك بنفسك برسم بيان برتبة
      \\(order\\geq 2\\).
    </p>
    <p>
      ولكن لماذا يحدث هذا؟
      حاول أن تأتي بتفسير.
      يمكنك مساعدة نفسك بمحاولة رسم بيان حيث جميع الرؤوس لها درجات مميزة.
    </p>
    <div class="hint">
      <span class="hint-word">
        تلميح:
      </span>
      افترض أن
      \\(order=n\\)
      وفكر في نطاق قيمة الدرجة من حيث
      \\(n\\).
    </div>
    <div class="toggle-container">
      <span class="toggle-link target-hidden">
        انقر لرؤية التفسير
      </span>
      <div class="toggle-content">
        <p>
          افترض أن بياننا برتبة
          \\(order=n\\).
          يمكن أن يتصل الرأس بحد أقصى
          \\(n-1\\)
          من الرؤوس الأخرى. لذا
          \\(0 \\leq deg(v_i) \\leq n-1\\).
        </p>
        <p>
          يبدو أنه بالنسبة لرؤوسنا
          \\(n\\)،
          هناك
          \\(n\\)
          من الخيارات للدرجة (من
          \\(0\\)
          إلى
          \\(n-1\\)).
          لذا، إذا اعتبرنا الدرجات المميزة كأبراج والقمم كحمامات،
          ألا ينبغي أن تكون
          \\(n\\)
          من الدرجات المميزة ممكنة إذن؟
        </p>
        <p>
          لا. ملاحظاتنا الإضافية تكشف السبب.
        </p>
        <p>
          لاحظ أنه في بيان برتبة
          \\(n\\)،
          لا يمكن أن توجد رؤوس بدرجات
          \\(0\\)
          و
          \\(n-1\\)
          في نفس الوقت.
        </p>
        <p>
          إذا كان هناك رأس بدرجة
          \\(0\\)،
          فهذا يعني أن هذا الرأس غير متصل بأي رأس آخر.
          وبالتالي، لا يمكن أن يكون هناك رأس متصل بجميع
          \\(n-1\\)
          من الرؤوس الأخرى. لذا نحصل على
          \\(0 \\leq deg(v_i) \\leq n-2\\)
          في هذه الحالة.
        </p>
        <p>
          إذا لم يكن هناك رأس بدرجة
          \\(0\\)،
          فإننا نحصل على
          \\(1 \\leq deg(v_i) \\leq n-1\\)
          في هذه الحالة.
        </p>
        <p>
          في كلتا الحالتين السابقتين، لدينا
          \\(n\\)
          من الرؤوس (حمامات) ولكن فقط
          \\(n-1\\)
          من الدرجات الممكنة (أبراج).
          لذا نحن متأكدون من أن هناك برج (درجة) يحتوي على أكثر من حمامة (رأس).
        </p>
      </div>
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        عليه.
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          حرك المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text"  style="text-align: center">
    </div>`,

    "prev": "?havel-hakimi",
    "next": "?regular-graph",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "regular-graph": {

    "content-title": "بيان منتظم",

    "theory-content": `
    <p>
      البيان الذي تكون فيه جميع الرؤوس لها نفس الدرجة يسمى
      <b>
        بيان منتظم
        (Regular Graph)
      </b>.
    </p>
    <p>
      البيان المنتظم الذي تكون درجة كل رأس فيه
      \\(k\\)
      يسمى
      \\(k\\)-منتظم.
    </p>
    <p>
      يظهر الشكل المجاور بيان
      \\(3\\)-منتظم
      برتبة
      \\(6\\).
    </p>
    <p>
      حاول إنشاء البيانات المنتظمة التالية.
    </p>
    <p>
      \\(1\\)-منتظم
      برتبة
      \\(2\\)
    </p>
    <p>
      \\(1\\)-منتظم
      برتبة
      \\(6\\)
    </p>
    <p>
      \\(2\\)-منتظم
      برتبة
      \\(3\\)
    </p>
    <p>
      \\(2\\)-منتظم
      برتبة
      \\(5\\)
    </p>
    <p>
      \\(4\\)-منتظم
      برتبة
      \\(5\\)
    </p>
    <p>
      \\(4\\)-منتظم
      برتبة
      \\(6\\)
    </p>
    <p>
      \\(4\\)-منتظم
      برتبة
      \\(7\\)
    </p>
    <p>
      \\(5\\)-منتظم
      برتبة
      \\(6\\)
    </p>
    <p>
      لا نُقدم حلول للمسائل المذكورة أعلاه.
      يجب أن تكون قادرًا على حلها بنفسك.
      إذا واجهت صعوبة في رسم هذه البيانات،
      يمكنك رؤية التلميح المقدم أدناه.
      لكن يجب أن تحاول أولاً.
    </p>
    <div class="hint toggle-container">
      <span class="toggle-link target-hidden">
        انقر لرؤية التلميح
      </span>
      <div class="toggle-content">
        <span class="hint-word">
          تلميح:
        </span>
        حدد متتالية الدرجات للبيان المنتظم.
        ثم استخدم هافيل-حكيمي لإنشاء البيان.
        لاحظ أن النص في الرأس يمثل درجته وليس الدرجة المستهدفة.
      </div>
    </div>
    <p>
      مهمة صغيرة لك الآن.
      احسب عدد الأضلاع في بيان
      \\(k\\)-منتظم
      برتبة
      \\(n\\).
      ابدأ بإنشاء وملاحظة البيانات المنتظمة ذات الرتب الصغيرة.
      في حال لم تحصل على الإجابة، يوجد أدناه الإجابة.
    </p>
    <div class="result toggle-container">
      <span class="toggle-link target-hidden">
        انقر لرؤية الإجابة
      </span>
      <div class="toggle-content">
        \\[|E|=\\frac{nk}{2}\\]
        هذا مشتق من حقيقة أن مجموع الدرجات هو ضعف عدد الأضلاع.
        \\[\\sum deg(v_i)=2|E|\\]
        هنا مجموع الدرجات هو
        \\(nk\\).
        <br>
        إن مجموع الدرجات
        (\\(nk\\))
        سيكون عددًا فرديًا عندما يكون كل من
        \\(n\\)
        و
        \\(k\\)
        فرديين.
        لكن لا يمكن أن يكون عدد الأضلاع عددًا كسريًا،
        وبالتالي لا يمكن أن يوجد بيان منتظم حيث يكون كل من
        \\(n\\)
        و
        \\(k\\)
        فرديين.
      </div>
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        عليه.
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          حرك المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?pigeonhole",
    "next": "?complete-graph",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "complete-graph": {

    "content-title": "بيان تام",

    "theory-content": `
    <p>
      البيان الذي يكون فيه كل رأس متصل بكل رأس آخر يسمى
      <b>
        بيان تام
        (Complete Graph)
      </b>.
    </p>
    <p>
      لاحظ أن درجة كل رأس ستكون
      \\(n-1\\),
      حيث
      \\(n\\)
      هو رتبة البيان.
    </p>
    <p>
      لذا يمكننا القول أن البيان التام من الرتبة
      \\(n\\)
      ليس إلا بيان
      \\((n-1)\\)-منتظم
      من الرتبة
      \\(n\\).
    </p>
    <p>
      البيان التام من الرتبة
      \\(n\\)
      يرمز له بـ
      \\(K_n\\).
    </p>
    <p>
      الشكل المجاور يظهر بيان تام من الرتبة
      \\(5\\).
    </p>
    <p>
      ارسم بعض البيانات التامة بنفسك وراقب عدد الأضلاع.
    </p>
    <p>
      قد تكون لاحظت أن عدد الأضلاع في البيان التام هو
      \\(\\frac{n(n-1)}{2}\\).
      هذا هو الحجم الأقصى الممكن تحقيقه لبيان من الرتبة
      \\(n\\)
      كما تعلمت في
      <a href="?order-and-size">
        درس الرتبة والحجم
      </a>.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?regular-graph",
    "next": "?bipartite",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "bipartite": {

    "content-title": "بيان ثنائي الفرع",

    "theory-content": `
    <p>
      يقال أن البيان
      <b>
        ثنائي الفرع
        (Bipartite)
      </b>
      إذا استطعنا تقسيم مجموعة الرؤوس إلى مجموعتين منفصلتين بحيث لا يوجد ضلع بين الرؤوس التي تنتمي لنفس المجموعة.
    </p>
    <p>
      لنفصل الأمر.
    </p>
    <p>
      نقوم بتقسيم مجموعة الرؤوس إلى مجموعتين.
      كل رأس يذهب إلى واحدة من هذه المجموعات.
      هذا يشبه تصنيف كل رأس إما بـ A أو B.
    </p>
    <p>
      كل رأس له تصنيف واحد فقط.
      لذا فإن المجموعتين
      <b>
        منفصلتان
        (Disjoint)
      </b>
      أي أن المجموعتين لا تحتويان على أي رأس مشترك.
    </p>
    <p>
      ولا ينبغي أن يكون هناك أي ضلع يمتد داخل نفس المجموعة.
      هذا يعني أن كل ضلع يمتد بين رأسين ينتميان إلى مجموعتين مختلفتين &mdash; واحد مصنف كـ A والآخر كـ B.
    </p>
    <p>
      لذا إذا استطعنا تصنيف رؤوسنا بهذه الطريقة، فإن البيان يكون ثنائي الفرع.
      وإلا فلا.
    </p>
    <p>
      ارسم بعض البيانات بنفسك لفهمها بشكل أفضل.
    </p>
    <p>
      بالنسبة للبيان ثنائي الفرع في الشكل المجاور، تظهر رؤوس المجموعة
      \\(A\\)
      و
      \\(B\\)
      باللونين البرتقالي والأخضر، على التوالي.
      إذا لم يكن ثنائي الفرع، فستكون الرؤوس بألوانها المعتادة.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      الرؤوس المعزولة لا تؤثر على ما إذا كان البيان ثنائي الفرع أم لا.
      يمكن تجاهلها.
    </div>
    <p>
      الرؤوس المعزولة ملونة بالفضي لإظهار أن هذه الرؤوس يتم تجاهلها.
      يمكن وضعها عشوائيًا في أي مجموعة، وسيظل بياننا ثنائي الفرع (أو غير ثنائي الفرع).
    </p>
    <p>
      هل كنت تولي اهتمامًا لمجموع درجات المجموعتين؟
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة:
      </span>
      في البيان ثنائي الفرع، مجموع درجات رؤوس كل مجموعة يساوي عدد الأضلاع.
      \\[
      \\sum_{v \\in A}deg(v)=\\sum_{v \\in B}deg(v)=|E|
      \\]
    </div>
    <p>
      لماذا هذا صحيح؟
      حاول أن تجد السبب بنفسك.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?complete-graph",
    "next": "?complete-bipartite",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "complete-bipartite": {

    "content-title": "بيان ثنائي الفرع تام",

    "theory-content": `
    <p>
      البيان
      <b>
        ثنائي الفرع التام
        (Complete Bipartite)
      </b>
      هو نوع خاص من
      <a href="?bipartite">
        البيان ثنائي الفرع
      </a>
      حيث يكون كل رأس من مجموعة متصل بكل رأس من المجموعة الأخرى.
    </p>
    <p>
      الشكل المجاور يظهر بيان ثنائي الفرع حيث تتكون المجموعة
      \\(A\\)
      (باللون البرتقالي) من
      \\(2\\)
      رأسًا وتحتوي المجموعة
      \\(B\\)
      (باللون الأخضر) على
      \\(3\\)
      رؤوس.
    </p>
    <p>
      إذا كانت المجموعتان تحتويان على
      \\(p\\)
      و
      \\(q\\)
      من الرؤوس، فإننا نرمز للبيان الثنائي الفرع التام بـ
      \\(K_{p,q}\\).
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      لا تخلط بين الترميز
      \\(K_{p,q}\\)
      و
      \\(K_n\\).
      الأول يستخدم للبيان الثنائي الفرع التام، والثاني يرمز إلى
      <a href="?complete-graph">
        البيان التام
      </a>.
      كلاهما مختلف.
    </div>
    <div class="result">
      <span class="result-word">
        خصائص:
      </span>
      النتائج التالية صحيحة للبيان الثنائي الفرع التام
      \\(K_{p,q}\\).
      <p></p>
      <ul>
        <li>
          رتبة البيان هي
          \\(|V|=p+q\\).
        </li>
        <li>
          حجم البيان هو
          \\(|E|=pq\\).
          <br>
          يمكن استخدام هذا للتحقق مما إذا كان البيان ثنائي الفرع تامًا أم لا.
        </li>
        <li>
          <a href="?degree-seqeunce">
            متتالية الدرجات
          </a>
          هي
          \\((p,p,...,p,q,...,q)\\)
          حيث يتكرر
          \\(p\\)
          \\(q\\)
          مرات ويتكرر
          \\(q\\)
          \\(p\\)
          مرات.
          يُفترض هنا أن
          \\(p>q\\).
        </li>
      </ul>
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?bipartite",
    "next": "?walk",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "walk": {

    "content-title": "ممر",

    "theory-content": `
    <p>
      <b>
        الممر
        (Walk)
      </b>
      هو تسلسل من الرؤوس المتجاورة (أو الأضلاع) في بيان.
    </p>
    <p>
      يمكنك التفكير في الرؤوس كمدن والأضلاع كطرق سريعة تربط بينها.
      تبدأ في مدينة وتبدأ بالسفر إلى مدن أخرى.
      ثم يمكن أن يسمى المسار الذي سافرت عبره بـ "ممر".
    </p>
    <p>
      لوصف المسار بشكل فريد،
      عليك سرد المدن والطرق السريعة التي سافرت فيها بهذا الترتيب.
      هذه هي فكرة الممر.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      لا يمكنك فقط سرد الرؤوس (أو الأضلاع) بشكل عشوائي وتسميته ممرًا.
      يجب أن يكون الرأس التالي متجاورًا مع الرأس السابق.
    </div>
    <p>
      أثناء السفر بين المدن،
      قد تكون قد زرت بعض المدن مرة أخرى وقد تكون قد سافرت عبر نفس الطريق السريع عدة مرات.
    </p>
    <p>
      وبالمثل، في الممر يمكنك تكرار الرؤوس والأضلاع.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      يمكن أن يحتوي الممر على رؤوس وأضلاع عدة مرات.
      ومع ذلك،
      في هذا التطبيق لن تتمكن من إضافة نفس الضلع مرة أخرى إلى الممر.
    </div>
    <p>
      عدد الأضلاع في الممر يسمى
      <b>
        الطول
        (Length)
      </b>
      للممر.
      وهو أقل بواحد من عدد الرؤوس في الممر.
      يتم احتساب الأضلاع (أو الرؤوس) المكررة في كل مرة تظهر فيها في الممر.
    </p>
    <p>
      اقرأ التعليمات أدناه وأنشئ بعض الممرات بنفسك.
      افعل ذلك حتى تفهم ما هو الممر.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
      <li>
        لبدء ممر، انقر على أي ضلع.
      </li>
      <li>
        الرؤوس
        <span style="background-color: #ff0; padding: 2px;">
          الأولى
        </span>
        و
        <span style="background-color: #8f3; padding: 2px;">
          الأخيرة
        </span>
        في الممر لها حدود ملونة.
      </li>
      <li>
        لإضافة الضلع التالي إلى الممر، انقر على ضلع يقع على الرأس
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر.
      </li>
      <li>
        يمكن إزالة الضلع
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر بالنقر عليه مرة أخرى.
      </li>
      <li>
        لن تتمكن من حذف الرؤوس/الأضلاع التي هي جزء من الممر.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>
    <button type="button" id="clear-walk" class="btn btn-default">
      مسح الممر
    </button>
    <button type="button" id="reverse-walk" class="btn btn-default">
      عكس الممر
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?complete-bipartite",
    "next": "?open-vs-closed",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "open-vs-closed": {

    "content-title": "الممرات المفتوحة مقابل المغلقة",

    "theory-content": `
    <p>
      يشرح هذا الدرس بعض الأنواع الخاصة من الممرات.
      تعرف عليها وجربها.
      لكن لاحظ أن المصطلحات التالية قد تختلف عن كتابك المدرسي.
    </p>
    <p>
      يقال أن الممر
      <b>
        مفتوح
        (Open)
      </b>
      إذا كانت الرؤوس الأولى والأخيرة مختلفة، أي أن الرؤوس الطرفية مختلفة.
    </p>
    <p>
      يقال أن الممر
      <b>
        مغلق
        (Closed)
      </b>
      إذا كانت الرؤوس الأولى والأخيرة هي نفسها.
      هذا يعني أنك تبدأ المشي عند رأس وتنتهي عند نفس الرأس.
    </p>
    <p>
      قبل المتابعة، حاول رسم ممرات مفتوحة ومغلقة لفهمها بشكل أفضل.
      أدناه بعض المصطلحات الأخرى التي تحتاج إلى معرفتها.
    </p>
    <p>
      <b>
        المسرب
        (Trail)
      </b>
      هو ممر مفتوح حيث يمكن تكرار الرؤوس، ولكن ليس الأضلاع.
    </p>
    <p>
      <b>
        المسار
        (Path)
      </b>
      هو ممر مفتوح بدون تكرار للرؤوس والأضلاع.
    </p>
    <p>
      إذا جعلت المسرب (أو المسار) مغلقًا بتطابق الرؤوس الطرفية
      فإن ما تحصل عليه يسمى حلقة (أو دورة).
    </p>
    <p>
      <b>
        الحلقة
        (Circuit)
      </b>
      هي ممر مغلق حيث يمكن تكرار الرؤوس، ولكن ليس الأضلاع.
    </p>
    <p>
      <b>
        الدورة
        (Cycle)
      </b>
      هي ممر مغلق حيث لا يمكن تكرار الرؤوس ولا الأضلاع.
      ولكن نظرًا لأنها مغلقة،
      فإن الرؤوس الأولى والأخيرة هي نفسها (تكرار واحد).
    </p>
    <p>
      من السهل الخلط بين هذه المصطلحات.
      لذا جرب حتى تشعر بالراحة.
      تذكر أنك لن تتمكن من تكرار الأضلاع في التطبيق.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      المسار هو نوع خاص من المسرب حيث لا تتكرر الرؤوس.
      وبالمثل، الدورة هي نوع خاص من الحلقة.
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
      <li>
        لبدء ممر، انقر على أي ضلع.
      </li>
      <li>
        الرؤوس
        <span style="background-color: #ff0; padding: 2px;">
          الأولى
        </span>
        و
        <span style="background-color: #8f3; padding: 2px;">
          الأخيرة
        </span>
        في الممر لها حدود ملونة.
      </li>
      <li>
        لإضافة الضلع التالي إلى الممر، انقر على ضلع يقع على الرأس
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر.
      </li>
      <li>
        يمكن إزالة الضلع
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر بالنقر عليه مرة أخرى.
      </li>
      <li>
        لن تتمكن من حذف الرؤوس/الأضلاع التي هي جزء من الممر.
      </li>
    </ul>`,

      "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>
    <button type="button" id="clear-walk" class="btn btn-default">
      مسح الممر
    </button>
    <button type="button" id="reverse-walk" class="btn btn-default">
      عكس الممر
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?walk",
    "next": "?connectivity",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "connectivity": {

    "content-title": "الاتصال",

    "theory-content": `
    <p>
      يقال أن البيان
      <b>
        مترابط
        (Connected)
      </b>
      إذا كان يمكن رسم مسار بين أي رأسين من رؤوسه.
      وإلا، فإنه يسمى
      <b>
        منفصل
        (Disconnected)
      </b>.
    </p>
    <p>
      كل بيان جزئي مترابط بشكل أقصى
      (لا يمكن إضافة المزيد من الرؤوس إليه دون جعله منفصل)
      يسمى
      <b>
        مكون مترابط
        (Connected Component)
      </b>
      أو فقط
      <b>
        مكون
        (Component)
      </b>
      للبيان.
    </p>
    <p>
      بما أن المكون مترابط بشكل أقصى:
    </p>
    <ul>
      <li>
        لا يمكن رسم مسار بين رأس "خارجي" وأي من رؤوس المكون.
      </li>
      <li>
        هناك مسار من أي رأس في المكون إلى أي رأس آخر في المكون.
      </li>
    </ul>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      <b>
        الرأس المعزول هو مكون
      </b>
      لأنه لا يوجد رأس في المكون غير متصل به,
      ولا يوجد رأس "خارجي" متصل به.
    </div>
    <p>
      الشكل المجاور يظهر بيان منفصل يحتوي على ثلاث مكونات - البرتقالي, الأخضر والأحمر.
    </p>
    <p>
      ارسم بعض البيانات بنفسك وتعود المصطلحات.
      كل مكون سيكون له لون خاص به.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس أو ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
      <li>
        لبدء ممر، انقر على أي ضلع.
      </li>
      <li>
        الرؤوس
        <span style="background-color: #ff0; padding: 2px;">
          الأولى
        </span>
        و
        <span style="background-color: #8f3; padding: 2px;">
          الأخيرة
        </span>
        في الممر لها حدود ملونة.
      </li>
      <li>
        لإضافة الضلع التالي إلى الممر، انقر على ضلع يقع على الرأس
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر.
      </li>
      <li>
        يمكن إزالة الضلع
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر بالنقر عليه مرة أخرى.
      </li>
      <li>
        لن تتمكن من حذف الرؤوس/الأضلاع التي هي جزء من الممر.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>
    <button type="button" id="clear-walk" class="btn btn-default">
      مسح الممر
    </button>
    <button type="button" id="reverse-walk" class="btn btn-default">
      عكس الممر
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?open-vs-closed",
    "next": "?eulerian-circuit",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "eulerian-circuit": {

    "content-title": "حلقة أويلرية",

    "theory-content": `
    <p>
      الحلقة التي تزور كل ضلع من أضلاع البيان مرة واحدة فقط تسمى
      <b>
        حلقة أويلرية
        (Eulerian Circuit)
      </b>.
      بمعنى آخر، الحلقة الأويلرية هي ممر مغلق يزور كل ضلع من أضلاع البيان مرة واحدة فقط.
    </p>
    <p>
      البيان الذي يحتوي على حلقة أويلرية يعرف باسم
      <b>
        بيان أويلري
        (Eulerian Graph)
      </b>.
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة:
      </span>
      البيان المترابط هو أويلري إذا وفقط إذا كانت درجة كل رأس عددًا زوجيًا.
    </div>
    <p>
      لاحظ التكافؤ
      (<i>إذا وفقط إذا</i>)
      في المبرهنة أعلاه.
      هذا يعني أن:
    </p>
    <ol>
      <li>
        إذا كان البيان المترابط يحتوي على جميع رؤوسه بدرجات زوجية،
        فإنه يحتوي على حلقة أويلرية.
      </li>
      <li>
        إذا كان البيان المترابط يحتوي على حلقة أويلرية،
        فإن جميع رؤوسه لها درجات زوجية.
      </li>
    </ol>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      بما أن الحلقة دورية بطبيعتها،
      يمكن اعتبار أي رأس كنقطة بداية لبناء حلقة أويلرية في بيان أويلري.
    </div>
    <p>
      مهمتك هي رسم حلقة أويلرية لكل من البيانات المعطاة.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
      <li>
        لبدء ممر، انقر على أي ضلع.
      </li>
      <li>
        الرؤوس
        <span style="background-color: #ff0; padding: 2px;">
          الأولى
        </span>
        و
        <span style="background-color: #8f3; padding: 2px;">
          الأخيرة
        </span>
        في الممر لها حدود ملونة.
      </li>
      <li>
        لإضافة الضلع التالي إلى الممر، انقر على ضلع يقع على الرأس
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر.
      </li>
      <li>
        يمكن إزالة الضلع
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر بالنقر عليه مرة أخرى.
      </li>
      <li>
        لن تتمكن من حذف الرؤوس/الأضلاع التي هي جزء من الممر.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="prev-prob" class="btn btn-default">
      السابق
    </button>
    <button type="button" id="clear-walk" class="btn btn-default">
      مسح الممر
    </button>
    <button type="button" id="reverse-walk" class="btn btn-default">
      عكس الممر
    </button>
    <button type="button" id="next-prob" class="btn btn-default">
      التالي
    </button>`,

    "svg-output": `
    <div class="text-center">
      <ul class="pagination" id="prob-list">
        <li>
          <a class="prob-current">
            1
          </a>
        </li>
        <li>
          <a>
            2
          </a>
        </li>
        <li>
          <a>
            3
          </a>
        </li>
        <li>
          <a>
            4
          </a>
        </li>
        <li>
          <a>
            5
          </a>
        </li>
      </ul>
    </div>`,

    "prev": "?connectivity",
    "next": "?eulerian-trail",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "eulerian-trail": {
    "content-title": "مسرب أويلري",

    "theory-content": `
    <p>
      الممر المفتوح الذي يزور كل ضلع من أضلاع البيان مرة واحدة فقط يسمى
      <b>
        ممر أويلري
        (Eulerian Walk)
      </b>.
      نظرًا لأنه مفتوح ولا يوجد تكرار للأضلاع، فإنه يسمى أيضًا
      <b>
        مسرب أويلري
        (Eulerian Trail)
      </b>.
    </p>
    <p>
      هناك علاقة بين المسارب الأويلرية والحلقات الأويلرية.
    </p>
    <p>
      نعلم أنه في البيان الأويلري، من الممكن رسم حلقة أويلرية بدءًا من أي رأس.
      ماذا لو قمنا بإزالة الضلع الأخير في هذه الحلقة؟
      هل لا يزال بإمكاننا المشي عبر جميع الأضلاع مرة واحدة فقط؟
    </p>
    <p>
      عند إزالة الضلع الأخير، سيكون للرأسين على هذا الضلع الآن درجات فردية.
      بقية الرؤوس ستظل لها درجات زوجية.
      لم تعد حلقتنا حلقة لأن الرؤوس الطرفية مختلفة.
      ما لدينا الآن هو مسرب يغطي جميع الرؤوس مرة واحدة فقط.
    </p>
    <div class="result">
      <p>
        <span class="result-word">
          مبرهنة:
        </span>
        يحتوي البيان المترابط على مسرب أويلري إذا وفقط إذا كان هناك رأسان بالضبط لهما درجة فردية والباقي له درجات زوجية.
      </p>
      <p>
        يجب أن يكون الرأسين ذوي الدرجة الفردية هما
        الرؤوس الطرفية
        في المسرب.
      </p>
    </div>
    <p>
      لاحظ التكافؤ
      (<i>إذا وفقط إذا</i>)
      في النتيجة أعلاه.
    </p>
    <p>
      ارسم المسارب الأويلرية للبيانات المترابطة المعطاة جانباً.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس أو الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
      <li>
        لبدء ممر، انقر على أي ضلع.
      </li>
      <li>
        الرؤوس
        <span style="background-color: #ff0; padding: 2px;">
          الأولى
        </span>
        و
        <span style="background-color: #8f3; padding: 2px;">
          الأخيرة
        </span>
        في الممر لها حدود ملونة.
      </li>
      <li>
        لإضافة الضلع التالي إلى الممر، انقر على ضلع يقع على الرأس
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر.
      </li>
      <li>
        يمكن إزالة الضلع
        <span style="background-color: #8f3; padding: 2px;">
          الأخير
        </span>
        في الممر بالنقر عليه مرة أخرى.
      </li>
      <li>
        لن تتمكن من حذف الرؤوس/الأضلاع التي هي جزء من الممر.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="prev-prob" class="btn btn-default">
      السابق
    </button>
    <button type="button" id="clear-walk" class="btn btn-default">
      مسح الممر
    </button>
    <button type="button" id="reverse-walk" class="btn btn-default">
      عكس الممر
    </button>
    <button type="button" id="next-prob" class="btn btn-default">
      التالي
    </button>`,

    "svg-output": `
    <div class="text-center">
      <ul class="pagination" id="prob-list">
        <li>
          <a class="prob-current">
            1
          </a>
        </li>
        <li>
          <a>
            2
          </a>
        </li>
        <li>
          <a>
            3
          </a>
        </li>
        <li>
          <a>
            4
          </a>
        </li>
        <li>
          <a>
            5
          </a>
        </li>
      </ul>
    </div>`,

    "prev": "?eulerian-circuit",
    "next": "?graph-coloring",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "graph-coloring": {

    "content-title": "تلوين البيان",

    "theory-content": `
    <p>
      <b>
        تلوين البيان
        (Graph Coloring)
      </b>
      هو تخصيص ألوان لكل رأس في البيان بحيث لا يحصل رأسين متجاورين على نفس اللون.
    </p>
    <p>
      أحيانًا، يُشار إلى هذا أيضًا باسم
      <b>
        التلوين الفعلي او المناسب
        (Proper Coloring)
      </b>
      للبيان.
    </p>
    <p>
      يمكنك تغيير لون الرأس بالنقر بزر الفأرة الأيسر عليه.
      في هذه الوحدة لديك 10 ألوان متاحة لكل رأس.
    </p>
    <p>
      جرب بنفسك على البيان وشاهد النتائج!
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لتغيير
        <span style="color:#fff; background-color:#d62728; padding:0 2px;">
          لون
        </span>
        الرأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        عليه.
      </li>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس/الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?eulerian-trail",
    "next": "?k-colorable",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "k-colorable": {

    "content-title": "بيان قابل للتلوين بـ k ألوان",

    "theory-content": `
    <p>
      يقال أن البيان
      \\(k\\)-قابل للتلوين
      إذا كان يمكن تلوينه بشكل فعلي باستخدام
      \\(k\\)
      من الألوان.
    </p>
    <p>
      على سبيل المثال، البيان
      <a href="?bipartite">
        ثنائي الفرع
      </a>
      هو
      \\(2\\)-قابل للتلوين.
      لرؤية ذلك، قم فقط بتخصيص لونين مختلفين للمجموعتين المنفصلتين في البيان ثنائي الفرع.
    </p>
    <p>
      وبالعكس، إذا كان البيان
      \\(2\\)-قابل للتلوين،
      فإن الرؤوس التي لها نفس اللون يمكن اعتبارها كمجموعات منفصلة.
      ومن ثم، نصل إلى النتيجة التالية:
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة:
      </span>
      البيان ثنائي الفرع إذا وفقط إذا كان
      \\(2\\)-قابل للتلوين.
    </div>
    <p>
      الآن، اعتبر بيانًا ملونًا بـ
      \\(k\\)
      ألوان.
      اختر أي رأس من البيان واستبدل لونه بلون جديد
      (لون ذو الرقم
      \\(\\left(k+1\\right)\\)
      ).
      من الواضح أن البيان لا يزال ملونًا بشكل فعلي.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      إذا كان البيان
      \\(k\\)-قابل للتلوين،
      فإنه أيضًا
      \\(\\left(k+n\\right)\\)-قابل للتلوين،
      \\(n \\geq 1\\).
    </div>
    <p>
      شيء آخر يستحق الملاحظة هو أن البيان
      \\(1\\)-قابل للتلوين
      إذا وفقط إذا كان منفصل تمامًا، أي أن جميع رؤوسه معزولة.
    </p>
    <p>
      في كل من التمارين التالية، يُعطى لك بيان وعدد محدود من الألوان.
      مهمتك هي تلوين البيانات (بشكل فعلي).
      حاول
      <b>
        تقليل
      </b>
      عدد الألوان التي تستخدمها.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لتغيير
        <span style="color:#fff; background-color:#d62728; padding:0 2px;">
          لون
        </span>
        الرأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحب
        </b>
        الرأس.
      </li>
      <li>
        لرؤية اسم الرأس/الضلع
        <b>
          مرر المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="prev-prob" class="btn btn-default">
      السابق
    </button>
    <button type="button" id="next-prob" class="btn btn-default">
      التالي
    </button>`,

    "svg-output": `
    <div id="output-text"  style="text-align: center">
    </div>
    <div class="text-center">
      <ul class="pagination" id="prob-list">
        <li>
          <a class="prob-current">
            1
          </a>
        </li>
        <li>
          <a>
            2
          </a>
        </li>
        <li>
          <a>
            3
          </a>
        </li>
        <li>
          <a>
            4
          </a>
        </li>
        <li>
          <a>
            5
          </a>
        </li>
        <li>
          <a>
            6
          </a>
        </li>
        <li>
          <a>
            7
          </a>
        </li>
        <li>
          <a>
            8
          </a>
        </li>
        <li>
          <a>
            9
          </a>
        </li>
        <li>
          <a>
            10
          </a>
        </li>
      </ul>
    </div>`,

    "prev": "?graph-coloring",
    "next": "?chromatic-number",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "chromatic-number": {
    "content-title": "العدد اللوني",

    "theory-content": `
    <p>
      <b>
        العدد اللوني
        (Chromatic number)
      </b>
      للبيان هو القيمة الدنيا لـ
      \\(k\\)
      التي يكون فيها البيان
      \\(k\\)-قابل للتلوين.
    </p>
    <p>
      بعبارة أخرى، هو الحد الأدنى لعدد الألوان اللازمة لتلوين فعلي للبيان.
    </p>
    <p>
      العدد اللوني للبيان
      \\(G\\)
      يرمز له بـ
      \\(\\chi(G)\\).
      والبيان الذي يكون
      \\(\\chi(G)=k\\)
      يسمى بيان
      <b>
        \\(k\\)-لوني
      </b>.
    </p>
    <p>
      قد تكون لاحظت في الفصل السابق (
      <a href="?k-colorable">
        بيان قابل للتلوين بـ
        \\(k\\)
        لون
      </a>)
      أن بعض المسائل تضمنت تلوينًا لونيًا.
    </p>
    <p>
      الآن نلقي نظرة على بعض الأنواع الشائعة من البيان وأعدادها اللونية.
    </p>
    <p>
      <b>
        <a href="javascript:setGraph(0);">
          بيان خاليِ
          (Empty Graph)
        </a>:
      </b>
      إنه بيان بدون أي أضلاع
      \\(|E|=0\\).
      جميع الرؤوس معزولة.
      \\(\\chi(G)=1\\).
      لاحظ أن البيان الخالي هو أيضًا
      <a href="?bipartite">
        ثنائي الفرع
      </a>.
    </p>
    <p>
      <b>
        <a href="javascript:setGraph(1);">
          بيان ثنائي الفرع
          (Bipartite Graph)
        </a>:
      </b>
      بيان ثنائي الفرع الخالي لديه
      \\(\\chi(G)=1\\).
      بيان ثنائي الفرع غير خالي لديه
      \\(\\chi(G)=2\\).
      باستخدام هذا، نصل إلى النتيجة التالية.
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة:
      </span>
      البيان
      \\(G\\)
      هو ثنائي الفرع إذا وفقط إذا كان
      \\(\\chi(G)\\leq2\\).
      <br><br>
      <p>
        يمكن إثبات ذلك بسهولة بملاحظة أن أي بيان يكون
        \\(\\chi(G)\\leq2\\)
        هو
        \\(2\\)-قابل للتلوين،
        وبالتالي ثنائي الفرع.
        العكس، قد تم إثباته سابقًا.
      </p>
    </div>
    <p>
      <b>
        <a href="javascript:setGraph(2);">
          بيان نجمي
          (Star Graph)
        </a>:
      </b>
      بيان نجمي من الرتبة
      \\(n+1\\)،
      يرمز له بـ
      \\(S_{n+1}\\)،
      هو البيان الثنائي التام
      \\(K_{1,n}\\)،
      حيث
      \\(n\\geq0\\).
      لذا، لديه نفس العدد اللوني كبيان ثنائي الفرع.
    </p>
    <p>
      <b>
        <a href="javascript:setGraph(3);">
          بيان حلقي
          (Cycle Graph)
        </a>:
      </b>
      بيان حلقي من الرتبة
      \\(n\\)
      يرمز له بـ
      \\(C_n\\).
      الحلقة ذات الرتبة الفردية لديها
      \\(\\chi(C_{2n+1})=3\\)،
      وتلك ذات الرتبة الزوجية لديها
      \\(\\chi(C_{2n})=2\\).
      لذا، الحلقة ذات الرتبة الزوجية هي أيضًا ثنائية الفرع.
    </p>
    <p>
      <b>
        <a href="javascript:setGraph(5);">
          بيان عجلة
          (Wheel Graph)
        </a>:
      </b>
      بيان عجلة من الرتبة
      \\(n+1\\)
      يتم الحصول عليه من
      \\(C_n\\)
      عن طريق توصيل جميع رؤوسه برأس جديد (يسمى
      <em>
        المحور
      </em>).
      بيان عجلة من الرتبة
      \\(n\\)
      يرمز له بـ
      \\(W_n\\).
      العجلة ذات الرتبة الفردية لديها
      \\(\\chi(W_{2n+1})=4\\)،
      وتلك ذات الرتبة الزوجية لديها
      \\(\\chi(W_{2n})=3\\).
    </p>
    <p>
      <b>
        <a href="javascript:setGraph(7);">
          بيان تام
          (Complete Graph)
        </a>:
      </b>
      بما أن كل رأس متصل بكل رأس آخر، لدينا
      \\(\\chi(K_n)=n\\).
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لتحريك رأس
        <b>
          اضغط Ctrl واسحبه
        </b>
        .
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          حرك المؤشر فوقه
        </b>
        .
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="prev-prob" class="btn btn-default">
      السابق
    </button>
    <button type="button" id="next-prob" class="btn btn-default">
      التالي
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>
    <div class="text-center">
      <ul class="pagination" id="prob-list">
        <li>
          <a class="prob-current">
            1
          </a>
        </li>
        <li>
          <a>
            2
          </a>
        </li>
        <li>
          <a>
            3
          </a>
        </li>
        <li>
          <a>
            4
          </a>
        </li>
        <li>
          <a>
            5
          </a>
        </li>
        <li>
          <a>
            6
          </a>
        </li>
        <li>
          <a>
            7
          </a>
        </li>
        <li>
          <a>
            8
          </a>
        </li>
      </ul>
    </div>`,

    "prev": "?k-colorable",
    "next": "?trees",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "trees": {

    "content-title": "الأشجار",

    "theory-content": `
    <p>
      حان الوقت لتعلم الأشجار.
      الأشجار هي نوع خاص من البيانات التي لها تطبيقات هائلة كهيكل بيانات في العلوم الحاسوبية.
    </p>
    <p>
      ولكن أولاً، نتحدث عن الغابات.
    </p>
    <p>
      <b>
        الغابة
        (Forest)
      </b>
      هي بيان لا حلقي، أي بيان بدون أي حلقات.
      يمكن أن تكون بيان مترابط واحد أو تحتوي على مكونات منفصلة متعددة.
      عندما تكون بيان مترابط واحد، نسميها شجرة.
    </p>
    <p>
      إذن، 
      <b>
        الشجرة
        (Tree)
      </b>
      هي بيان مترابط لا حلقي.
      والغابة هي مجرد مجموعة من شجرة واحدة أو أكثر.
    </p>
    <p>
      العب لترى ما هي الشجرة وما ليست كذلك.
      وحاول ملاحظة الخصائص التالية أثناء الرسم.
    </p>
    <div class="result">
      <span class="result-word">
        مبرهنة:
      </span>
      البيان المترابط هو شجرة إذا وفقط إذا كانت رتبته تزيد بواحد عن حجمه.
      بالصيغة الرياضية، يمكننا كتابة ذلك كـ
      \\[
      |V|=|E|+1
      \\]
      <p>
        لاحظ أن العبارة ثنائية الشرط.
        لذا فهي تقول أيضًا أن البيان المترابط الذي يحقق المعادلة أعلاه هو شجرة.
      </p>
    </div>
    <div class="result">
      <span class="result-word">
        خاصية:
      </span>
      للشجرة التي تحتوي على أكثر من رأس واحد، هناك
      <b>
        مسار فريد
      </b>
      بين أي رأسين من رؤوسها.
    </div>
    <div class="result">
      <span class="result-word">
        خاصية:
      </span>
      الشجرة
      <b>
        مترابطة بشكل أصغري
      </b>
      ، مما يعني أن إزالة أي ضلع عشوائي منها سيحولها إلى بيان منفصل.
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة رأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        على المساحة الفارغة.
      </li>
      <li>
        لإضافة ضلع
        <b>
          اسحب
        </b>
        من رأس إلى آخر.
      </li>
      <li>
        لحذف رأس/ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط مع الاستمرار على Ctrl واسحب
        </b>
        عليه.
      </li>
      <li>
        لرؤية اسم رأس/ضلع فقط
        <b>
          حرك المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الكل
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,

    "prev": "?chromatic-number",
    "next": "?rooted-trees",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "rooted-trees": {

    "content-title": "الأشجار بجذر",

    "theory-content": `
    <p>
      <b>
        الشجرة بجذر
        (Rooted Tree)
      </b>
      هي شجرة تحتوي على رأس خاص يسمى "الجذر".
    </p>
    <p>
      يعمل الجذر كنقطة مرجعية للرؤوس الأخرى في الشجرة.
      في الأشكال، نضع عادة الجذر في الأعلى ونضع الرؤوس الأخرى تحته.
    </p>
    <p>
      هذا المفهوم مفيد بشكل خاص في علوم الحاسوب للعمل مع هياكل البيانات القائمة على الأشجار.
    </p>
    <p>
      في الشكل المجاور، يظهر رأس الجذر بحدود سوداء.
    </p>
    <p>
      فيما يلي بعض المصطلحات المفيدة المرتبطة بالأشجار بجذر.
    </p>
    <p>
      <b>
        الفرع
        (Branch)
      </b>
      هو مجرد اسم آخر يُعطى لأضلاع الشجرة.
    </p>
    <p>
      <b>
        عمق رأس
        (Depth of a vertex)
      </b>
      هو عدد الفروع في المسار من الجذر إلى ذلك الرأس.
      لذا فإن عمق الجذر نفسه هو صفر.
    </p>
    <p>
      <b>
        مستوى رأس
        (Level of a vertex)
      </b>
      هو عدد الرؤوس في المسار من الجذر إلى ذلك الرأس.
      هذا يزيد بواحد عن عمق الرأس.
      مستوى الجذر هو 1.
    </p>
    <p>
      <b>
        ابن الرأس
        (Child of a vertex)
        \\(v_1\\)
      </b>
      هو أي رأس
      \\(v_2\\)
      متصل به بحيث يكون
      \\(d(v_2)=d(v_1)+1\\)
      ، حيث
      \\(d(v)\\)
      يدل على عمق الرأس
      \\(v\\).
      الرأس
      \\(v_1\\)
      يسمى
      <b>
        أب
        (Parent)
      </b>
      الرأس
      \\(v_2\\).
      عادة، في الأشكال، نضع رأس الأب فوق رؤوس الأبناء.
    </p>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      يمكن أن يكون هناك أبناء متعددين لرأس، لكن أب الرأس فريد.
      الجذر هو الرأس الوحيد في الشجرة بدون أي أب.
    </div>
    <p>
      <b>
        الورقة
        (Leaf)
      </b>
      هي رأس بدون أي ابن.
    </p>
    <p>
      <b>
        ارتفاع الشجرة
        (Height of tree)
      </b>
      هو القيمة القصوى للعمق لأي رأس في الشجرة.
    </p>
    <p>
      العب لتتعرف على هذه المصطلحات.
      بالمناسبة، هل لاحظت شيئًا عن الألوان؟
    </p>
    <div class="result">
      <p>
        <span class="result-word">
          مبرهنة:
        </span>
        جميع الأشجار ثنائية الفرع.
      </p>
      <p>
        يمكن رؤية ذلك بسهولة عن طريق تلوين جميع الرؤوس في العمق الزوجي بلون، لنقل الوردي، وتلوين الرؤوس في العمق الفردي بلون آخر، لنقل السماوي.
        لذا، أي شجرة قابلة للتلوين بلونين.
      </p>
    </div>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لإضافة ابن لرأس
        <b>
          انقر بزر الفأرة الأيسر
        </b>
        عليه.
      </li>
      <li>
        لحذف رأس غير الجذر وجميع أبنائه
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
      <li>
        لتحريك رأس
        <b>
          اضغط مع الاستمرار على Ctrl واسحب
        </b>
        عليه.
      </li>
      <li>
        لرؤية تفاصيل رأس/ضلع فقط
        <b>
          حرك المؤشر
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="clear-graph" class="btn btn-default">
      مسح الرسم البياني
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>`,


    "prev": "?trees",
    "next": "?spanning-tree",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  },

  "spanning-tree": {

    "content-title": "الشجرة المولدة لبيان",

    "theory-content": `
    <p>
      <b>
        الشجرة المولدة
        (Spanning Tree)
      </b>
      لبيان هي بيان جزئي له يشكل شجرة ويحتوي (أو يغطي) جميع رؤوس البيان.
    </p>
    <p>
      لذا إذا كان البيان المعطى
      \\(G\\)
      يحتوي على
      \\(n\\)
      رؤوس، فنحن نبحث عن بيان جزئي لـ
      \\(G\\)
      الذي
    </p>
    <ul>
      <li>
        يحتوي على
        \\(n\\)
        رؤوس
      </li>
      <li>
        يحتوي على
        \\(n-1\\)
        أضلاع
      </li>
      <li>
        مترابط
      </li>
    </ul>
    <div class="note">
      <span class="note-word">
        ملاحظة:
      </span>
      يجب أن يكون البيان نفسه مترابطًا للحصول على شجرته المولدة.
    </div>
    <p>
      لذا إذا كان البيان مترابطًا، نحتاج فقط إلى حذف بعض أضلاعه بحيث لا توجد حلقة ويبقى مترابطًا.
    </p>
    <p>
      في هذه التمارين، هدفك هو تقليل عدد الأضلاع إلى
      \\(n-1\\)
      مع الحفاظ على البيان مترابطًا.
    </p>
    <p>
      عند حل المسائل، ستدرك أن الشجرة المولدة لبيان ليست فريدة.
    </p>`,

    "interface-title": "واجهة التطبيق:",

    "interface-content": `
    <ul>
      <li>
        لحذف ضلع
        <b>
          انقر بزر الفأرة الأيمن
        </b>
        عليه.
      </li>
    </ul>`,

    "svg-buttons": `
    <button type="button" id="prev-prob" class="btn btn-default">
      السابق
    </button>
    <button type="button" id="next-prob" class="btn btn-default">
      التالي
    </button>`,

    "svg-output": `
    <div id="output-text" style="text-align: center">
    </div>
    <div class="text-center">
      <ul class="pagination" id="prob-list">
        <li>
          <a>1</a>
        </li>
        <li>
          <a>2</a>
        </li>
        <li>
          <a>3</a>
        </li>
        <li>
          <a>4</a>
        </li>
      </ul>
    </div>`,

    "prev": "?rooted-trees",
    "next": "",
    "script": "app.js",
    "star": "n",
    "style": "app.css"
  }

};
